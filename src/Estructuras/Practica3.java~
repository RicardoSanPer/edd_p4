package edd.src.Estructuras;

import java.util.Comparator;
import edd.src.Estructuras.Utilidad;
import java.lang.Math;

public class Practica3 {
    
    public static void sumaCercana(Lista<Integer> lista, int n)
    {
	/**crea una copia ordenada de la lista. Complejidad de O(nlog(n))
	 * pues mergeSort() tiene dicha complejidad de tiempo
	 */
	Lista<Integer> suma = lista.mergeSort(new Comparator<Integer>()
	    {
		@Override
		public int compare(Integer o1, Integer o2)
		{
		    return o1 - o2;
		}
	    });

	System.out.println(suma);
	
	IteradorLista<Integer> i = suma.iteradorLista();
	IteradorLista<Integer> d = suma.iteradorLista();

	d.end();
	
	int tempi = i.next();
	int tempd = d.previous();

	//System.out.println(tempd + " " + tempi);
	
	int diff = Integer.MAX_VALUE;

	int par1 =0;
	int par2 = 0;
	
	while(tempd > tempi)
	{
	    //System.out.println("Comparando "+ tempi + " " + tempd);

	    //diferencia
	    int tempdiff = tempi + tempd - n;
	    //valor absoluto
	    tempdiff = Utilidad.absoluto(tempdiff);

	    //si la diferencia es menor a la diferencia menor, actualiza el par
	    if(tempdiff < diff)
	    {
		par1 = tempi;
		par2 = tempd;
		
		//diff = temp;
		//valor absoluto
		diff = Utilidad.absoluto(tempdiff);
	    }

	    if(tempi + tempd > n)
	    {
		tempd = d.previous();
	    }
	    else
	    {
		tempi = i.next();
	    }
	    
	}
	System.out.println("El par más cercano es " + par1 + " y " + par2);
	
    }
    /**Funcion que llama la funcion que realiza el backtracking a partir de una sola cadena
     *@param cadena - String a permutar
     */
    public static void permutacionesCadena(String cadena)
    {
	int n = cadena.length();
	permutaciones(cadena, n, 0);
    }

    
    public static void primosQueSuman(int S, int P, int N)
    {
	Lista<Integer> primos = cribaM(S,P);
	System.out.println("Dados N = " + N + " P = " + P + " S = " + S);
        nChooseK(primos, N, S);
    }
    
    public static void N_Reinas(int N)
    {
	if(N>1&&N<=3)
	{
	    System.out.println("Sin solución");
	    return;
	}
	else if(N<=0)
	{
	    System.out.println("Cantidad Invalida");
	}
	int[][] tablero = new int[N][N];
	for(int i = 0; i < N; i++)
	{
	    for(int j = 0; j < N; j++)
	    {
		tablero[i][j]=0;
	    }
	}
	reinas(tablero, 0);
    }

    public static void sqrtBusqBin(int n)
    {
	if(n<0)
	{
	    System.out.println("Sin raiz real");
	    return;
	}
	else if(n==0 || n == 1)
	{
	    System.out.println("Raiz: " + n);
	}
	else
	{
	    double diff = n/2;
	    sqrtBin(n, diff, diff);
	}
    }

    public static void main(String[] args) {
        //Puedes hacer tus pruebas aqui

	Lista<Integer> test = new Lista<Integer>();

	for(int i = 0; i <= 20; i++)
	    {
		test.add((Integer)i);
	    }

	ArbolBinarioBusqueda<Integer> arbol = new ArbolBinarioBusqueda<Integer>();
	ArbolBinarioCompleto<Integer> arbol2 = new ArbolBinarioCompleto<Integer>(test);

	arbol.convertBST(arbol2);
	
	System.out.println("Pre eliminacion");
	System.out.println(arbol);
	System.out.println("Delete");
	arbol.delete(12);
	System.out.println(arbol);
	//System.out.println(test);
    }

    /**MergeSort para lista de enteros. Sin uso pues la clase lista tiene una implementacion generica
     *@param lista - lista de tipo integer a ordenar
     *@return lista ordenada
     */
    private static Lista<Integer> mergeSort(Lista<Integer> lista)
    {
	int size = lista.size();
	int n = size/2;
	int m = size - n;

	if(size == 1)
	{
	    return lista;
	}

	//sublistas
	Lista<Integer> izquierda = new Lista<Integer>();
	Lista<Integer> derecha = new Lista<Integer>();

	
	IteradorLista<Integer> it = lista.iteradorLista();
	int contador = 0;

	//Crea la lista con la mitad inferior (izquierda)
	while(contador < n && it.hasNext())
	{
	    izquierda.add(it.next());
	    contador++;
	}
	contador = 0;

	//Crea la lista con la mitad superior (derecha)
	while(contador < m && it.hasNext())
	{
	    derecha.add(it.next());
	    contador++;
	}
	
	//System.out.println("I: "+izquierda);
	//System.out.println("D: "+derecha);

	izquierda = mergeSort(izquierda);
	derecha = mergeSort(derecha);

	//System.out.println("Izquierda: "+izquierda);
	//System.out.println("Derecha: "+derecha);	
	Lista<Integer> sorted = merge(izquierda, derecha);
	

	return sorted;
    }

    /**Merge. Une dos listas ordenando los elementos de menor a mayor. Auxiliar de MergeSort
     *@param izquierda - lista de la izquierda a unir
     *@param derecha - lista de la derecha a unir
     *@return lista unida y ordenada
     */
    private static Lista<Integer> merge(Lista<Integer> izquierda, Lista<Integer> derecha)
    {
	Lista<Integer> sorted = new Lista<Integer>();
	
	IteradorLista<Integer> itz = izquierda.iteradorLista();
	IteradorLista<Integer> itd = derecha.iteradorLista();

	//System.out.println("Merge I:" + izquierda + " d: "+ derecha);
	
	int i = izquierda.size();
	int d = derecha.size();
	
	int tempi = itz.next();
	int tempd = itd.next();
	
	while(i>0 && d>0)
	{
	    //Si el elemento de la izquierda es menor o igual al de la derecha,
	    //Se añade a la lista ordenada, se mueve el iterador izquierdo un espacio
	    //System.out.println("COmparando " + tempi+" "+tempd);
	    if(tempi <= tempd)
	    {
		sorted.add(tempi);
		//System.out.println("Pequeño "+tempi);
		if(itz.hasNext())
		{	
		    tempi = itz.next();
		}
		i--;
	    }
	    //Si el elemento de la derecha es menor o igual al de la derecha,
	    //Se añade a la lista ordenada, se mueve el iterador derecho un espacio
	    else
	    {
		sorted.add(tempd);
		//	System.out.println("Pequeño "+tempd);
		if(itd.hasNext())
		{
		    tempd = itd.next();
		}
		d--;
	    }
	}
	//Añade los elementos restantes de las listas.
	
	//izuierda
        if(i>0)//Mientras aun hayan elementos
	{
	    sorted.add(tempi);
	    while(itz.hasNext())
	    {
		sorted.add(itz.next());
	    }
	}

	//derecha
        if(d>0)//Mientras aun hayan elementos
	{
	    sorted.add(tempd);
	    while(itd.hasNext())
	    {
		sorted.add(itd.next());
	    }
	}
	//System.out.println("====Regresando " + sorted);
	return sorted;
    }
    /**Funcion que realiza las permutaciones mediante bakctracking.
     *@param cadena - String que se va a permutar
     *@param n - longitud de la cadena
     *@param i - indice del caracter sobre el cual se estan realizando las permutaciones.
     */
    private static void permutaciones(String cadena, int n, int i)
    {
	//Si ya no hay mas opciones, imprimir la cadena
	if(i==n)
	{
	    System.out.println(cadena);
	    return;
	}
	//de otro modo
	for(int j = i; j < n; j++)
	{
	    cadena = swap(cadena, i, j);
	    permutaciones(cadena, n, i+1);
	    //backtracking
	    cadena = swap(cadena, i, j);
	}
    }
    
    /**Intercambia dos caracteres de una cadena
     *@param cadena - cadena donde se realiza el cambio
     *@param x - indice del primer caracter a cambiar
     *@param y - indice del segundo caracter a cambiar
     *@return cadena con los caracteres intercambiados.
     */
    private static String swap(String cadena, int x, int y)
    {
	if(cadena == null || cadena.isEmpty()){return "";}
	if(x >= cadena.length() || y >= cadena.length() || x < 0 || y < 0)
	{
	    return "";
	}		

	char[] ch = cadena.toCharArray();
	char temp = cadena.charAt(x);

	ch[x] = ch[y];
	ch[y] = temp;

        return String.valueOf(ch);
	//System.out.println(str);
    }

    /**Crea una lista de todos los numeros primos menores a un número n
     *@paramn - numero hasta el cual se quieren hallar numeros primos
     *@return lista de enteros con los primos menores a n
     */
    public static Lista<Integer> criba(int n)
    {
	//Obtener la lista de todos los numeros de 2 a n
	Lista<Integer> primos = new Lista<Integer>();
	for(int i = 0; i <= n; i++)
	{
	    primos.add(i);
	}
	//raiz de n
	int raiz = (int)Math.sqrt(n);
	//System.out.println(raiz);

	//criba
	for(int i = 2; i <= raiz; i++)
	{
	    //System.out.println("Eliminando " + i);
	    if(primos.getElementAt(i)>0)
	    {
		//marca todos los multiplos de i
		for(int j = i; j <= n/i; j++)
		{
		    //System.out.println(i*j);
		    //los marca cambiando su valor por -1
		    primos.setElementAt(i*j, -1);
		}
	    }
	}
	
	//Nueva lista unicamente con los primos hallados
	Lista<Integer> criba = new Lista<Integer>();
	IteradorLista<Integer> it = primos.iteradorLista();
	
	while(it.hasNext())
	{
	    int m = it.next();
	    //añade a la lista todos los numeros no marcados (mayores a 1)
	    if(m>1)
	    {
		criba.add(m);
	    }
	}
	//System.out.println(criba);
	return criba;
    }
    
    /**Crea una lista de primos menores a un numero n y mayor a un primo p
     *@param n - numero cuyos primos menores se quieren hayar
     *@param p - primo cuyos primos maximos se quieren hallar
     *@return lista de enteros con los primos mayores a p y menores a n
     */
    private static Lista<Integer> cribaM(int n, int p)
    {
	Lista<Integer> primos = criba(n);
	//System.out.println(primos);
	IteradorLista<Integer> it = primos.iteradorLista();

	Lista<Integer> criba = new Lista<Integer>();
	
	int temp=0;
	while(it.hasNext())
	{
	    temp = it.next();
	    if(temp > p)
	    {
		criba.add(temp);
	    }
	}
	//System.out.println("imrpimiendo criba "+criba);
	return criba;
    }
    /**Crea todas las permutaciones posibles de tamaño k para un conjunto de tamaño n
     *@param lista - lista de enteros a permutar
     *@param k - tamaño de las permutaciones
     */
    private static void nChooseK(Lista<Integer> lista,  int k, int suma)
    {
	/*
	if(k == lista.size())
	{
	    System.out.println(lista);
	}
	*/
	if(k >= lista.size() || k < 1)
	{
	    System.out.println("Numero fuera de rango");
	}
	else
	{
	    chooseK(lista, k, k, 0, 0, suma);
	}
    }

    /**Funcion que calcula las permutaciones n choose k. Teniendo una coleccion de objetos, la
     *funcion acomoda la respuesta en los primeros k elementos de la coleccion e imprime dichos k elementos
     *cuando se completa una permutacion.
     *@param lista - lista de enteros a permutar
     *@param totalPemutaciones - tamaño de las combinaciones/permutaciones.
     *@param faltantes - cantidad faltante de elementos a acomodar para completar una permutacion
     *@param inicial - indice del elemento que será reemplazado para acomodar la permutacion
     *@param indiceMayor - indice del último que fue acomodado.
     *
     *
     *Teniendo un conjunto de elementos de tamaño n y queriendo hacer todas las permutaciones de tamaño k=total
     *Permutaciones:
     *
     *
     *La función acomoda cada permutación en los primeros k elementos de la coleccion, y al imprimir la 
     *respuesta imprime unicamente dichos k elementos. Por ello, la funcion permuta por los primero k indices
     *de la coleccion.
     *
     *La función toma un elemento cualquiera entre el indice inicial (0 para la primera recursion) y el 
     *indice n-faltantes (para garantizar que siempre hayan opciones) y lo acomoda en el indice indice inicial.
     * 
     *
     *Resta 1 a faltantes, aumenta el indice inicial (para que el siguiente elemento
     *sea acomodado en el indice que prosigue) y establece el indice mayor al indice del elemento que fue
     *puesto en el indice inicial, para que en recursiones posteriores la función tome unicamente
     *elementos en indices mayores a los ya elegidos.
     *
     *Por ejemplo, para el conjunto {A,B,C,D,E,F,G} 7 choose 3, toma cualquier elemento que tenga 
     *indice 0 o más y que sea menor o igual al indice 7-3 = 4. Si toma por ejemplo el elemento en el indice
     *3 (D), lo intercambia con el elemento en el indice inicial 0, y se tiene {D,B,C,A,E,F,G}. El indice
     *inicial se aumenta por uno para que el siguiente elemento elegido sea intercambiado con B. El indice
     *mayor será 3+1 = 4 para que la funcion elija un elemento que no haya sido elegido y que no sea el que
     *se descarto (A). Se resta 1 a faltantes, y se llama a la funcion con estos nuevos parametros.
     *
     *En la siguiente recursion, elegira un elemento con indice entre 4 y 7-2 = 5 (Es decir, elige entre
     *{E,F}). Si toma E, es intercambiado con B (indice inicial 1), con lo que se 
     *tiene {D,E,C,A,B,F,G}. El siguiente insice inicial es 2, el siguiente indice mayor es 4+1 = 5
     *y a faltantes le es restado 1.
     *
     *Estos pasos se repiten hasta que ya no hayan opciones faltantes, con lo que se procede a imprimir la 
     *respuesta
     */
    private static void chooseK(Lista<Integer> lista, int totalPermutaciones, int faltantes, int inicial, int indiceMayor, int total)
    {
	//System.out.println(k);
	//suma ++;
	
	//System.out.println(suma);
	//Si se agotaron las opciones, imprimir la respuesta
	if(faltantes==0)
	{
	    int suma = 0;
	    String texto = "";
	    IteradorLista<Integer> it = lista.iteradorLista();

	    //Verificar si es solucion
	    for(int i =0; i < totalPermutaciones; i++)
	    {
		int temp = it.next();
		texto += String.valueOf(temp) + " ";
		suma += temp;
	    }

	    //Si es resultado, imprime los primos
	    if(suma == total)
	    {
		it.start();
		System.out.printf("%s -> ", texto);
		for(int i = 0; i < totalPermutaciones; i++)
		{
		    System.out.printf("%d ",it.next());
		    if(i < totalPermutaciones-1)
		    {
			System.out.printf(" + ");
		    }
		}
		System.out.println(" = " + suma);
	    }
	    return;
	}
	
	int m = lista.size();
	
	//Iterar por los indices que faltan de acomodar, y elegir cualquier elemento
	//que no haya sido elegido y que tenga un indice mayor a uno a elegido
	for(int i = indiceMayor; i <= m - faltantes; i++)
	{
	    //System.out.println(m-faltantes);
	    lista.swap(inicial, i);

	    //System.out.println(cadena);
	    chooseK(lista, totalPermutaciones, faltantes -1, inicial+1, i+1, total);
	    
	    //System.out.println("Falt " + faltantes);
	    lista.swap(inicial, i);
	}

    }

    /**Funcion recursiva del problema de las reinas
     *@param tablero - array bidimensional donde se colocan las reinas
     *@param columna - columna donde se busca colocar una reina
     */
    private static void reinas(int[][] tablero, int columna)
    {
	
	int n = tablero.length;
	if(columna >= n)
	{
	    printTablero(tablero);
	    return;
	}		
	for(int i = 0; i < n; i++)
	{
	    if(esSeguro(tablero,columna,i))
	    {
		tablero[columna][i] = 1;

		reinas(tablero, columna+1);
		//backtrack
		tablero[columna][i] = 0;
		
	    }
	}
    }

    /**Verifica si se puede colocar una reina en una casilla del tablero sin que pueda ser
     *capturada por otra reina
     *@param tablero - tablero donde se va a colocar la reina
     *@param columna - columna donde se busca colocar
     *@param fila - fila donde se busca colocar
     *@return boolean - true si se puede colocar, false en otro caso
     */
    private static boolean esSeguro(int[][] tablero, int columna, int fila)
    {
	int n = tablero.length;
	//checar filas
	for(int i = 0; i < n; i++)
	{
	    if(tablero[columna][i] != 0)
	    {
		return false;
	    }
	}
	//checar columnas
	for(int i = 0; i < tablero.length; i++)
	{
	    if(tablero[i][fila]!=0)
	    {
		return false;
	    }		    
	}
	//checar diagonal
	int x = columna - fila;
	int y = 0;
	
        while(x < n && y < n)
	{
	    if(x>=0  && y >= 0 && tablero[x][y]!=0)
	    {
		return false;
	    }
	    x++;
	    y++;
	}
	//checar contradiagonal
	x = 0;
	y = fila + columna;
	while(x < n && y >= 0)
	{
	    if(x >= 0 && y < n && tablero[x][y] != 0)
	    {
		return false;
	    }
	    x++;
	    y--;
	}
	return true;
    }

    /**Imprime un tablero
     *@param tablero - tablero a imprimir
     */
    private static void printTablero(int[][] tablero)
    {
	int n = tablero.length;
	int temp = 0;
	for(int i = 0; i < n; i++)
	{
	    for(int j = 0; j < n; j++)
	    {
		temp = tablero[i][j];
		if(temp == 0)
		{
		    System.out.printf("[ ]");
		}
		else
		{
		    System.out.printf("[♛]");
		}			
		//System.out.printf("%d", tablero[i][j]);
	    }
	    System.out.println();
	}
	System.out.println();
    }
    /**Calcula la raíz de un entero mediante busqueda binaria con margen de 0.00001
     *@param n - entero cuya raiz se busca
     *@param diff - diferencia
     *@param aprox - aproximacion actual de la raiz
     */
    private static void sqrtBin(int n, double diff, double aprox)
    {
	double margen = 0.00001;
	double cuadrado = aprox * aprox;

	//si la diferencia entre el cuadrado de la aproximacion y n es menor al margen y mayor o igual a 0
	//imprime la raíz
	if((n - cuadrado) < margen && (n-cuadrado) >= 0)
	{
	    System.out.println("Raiz " + aprox);
	    return;
	}
	else
	{
	    //la diferencia será una n dividido por una potencia de 2
	    //para realizar la busqueda binaria
	    diff = diff/2;
	    double temp = 0;

	    //Si el cuadrado de la aproximación es mayor que n, busca un numero menor a la aproximacion
	    if(aprox * aprox > n)
	    {
		temp = aprox - diff;
		sqrtBin(n, diff, temp);
	    }
	    //en otro caso busca uno mayor
	    else
	    {
		temp = aprox + diff;
		sqrtBin(n, diff, temp);
	    }
	}
    }
}
